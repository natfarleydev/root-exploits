// gSystem->AddLinkedLibs("-lgsl -lgslcblas -lm");
// .include -I/usr/include

// Most of these are not needed as the CINT loads them
#include <iostream>
#include "TString.h" 		// Extra comment to demonstrate git
#include "Riostream.h"
#include "TH2.h"
#include "TNtuple.h"
#include "TF1.h"
#include "TMath.h"
#include "TCanvas.h"
#include "TGraph.h"
#include "TGaxis.h"
// #include <gsl/gsl_sf_lambert.h>


Double_t fitf(Double_t *x, Double_t *par)
{
  // A simple function to create c*(x^n)
  return par[0]*TMath::Power(x[0],par[1]);
}

// Double_t fitLambertW(Double_t * x, Double_t *par) {
// double prefactor = (par[0]*TMath::Power(x[0],par[1]));
// return prefactor * gsl_sf_lambert_W0( (1e-3)/(par[2]*prefactor) );
// // return gsl_sf_lambert_W0(x[0]-3e12);
// // return TMath::Power(x[0]-4e12,4);
// // return LambertW(x[0]+1e13);
// }

void on_the_fly_fit() {
  //  Read data from an ascii file and create a root file with an histogram and an ntuple.

  // Not sure why this bit is here, but I see it a lot in examples
  // And then I commented it out
  // TString dir = gSystem->UnixPathName(gInterpreter->GetCurrentMacroName());
  // dir.ReplaceAll("final_fit.C","");
  // dir.ReplaceAll("/./","/");
  // ifstream in;
  // in.open(Form("%sfirst_proper_run.dat",dir.Data()));

  // ifstream in;
  // in.open("cut_data.dat");

  // Declaring variables
  // Float_t x,y;
  // Int_t nlines = 0; // for a while loop a little below here

  // // Some stuff for the logs
  // const Int_t nxbins = 10000;
  // Double_t xmin = 1E10;
  // Double_t xmax = 1E16;
  // Double_t logxmin = TMath::Log10(xmin);
  // Double_t logxmax = TMath::Log10(xmax);
  // Double_t xbinwidth = (logxmax - logxmin)/nxbins;
  // Double_t xbins[nxbins+1];
  // xbins[0] = xmin;
  // for (Int_t i=1; i<=nxbins;i++) {
  // xbins[i] =  xmin + TMath::Power(10,logxmin+i*xbinwidth);
  // }

  // const Int_t nybins = 1000;
  // Double_t ymin = 3E-2;
  // Double_t ymax = 150;
  // Double_t logymin = TMath::Log10(ymin);
  // Double_t logymax = TMath::Log10(ymax);
  // Double_t ybinwidth = (logymax - logymin)/nybins;
  // Double_t ybins[nybins+1];
  // ybins[0] = ymin;
  // for (Int_t i=1; i<=nybins;i++) {
  // ybins[i] = ymin + TMath::Power(10,logymin+i*ybinwidth);
  // } 

  // TODO repeat the last bit of code for the y axis.
  // TH2F *h2 = new TH2F("h2","xy scatter",nxbins,xbins,nybins,ybins); // Define histogram, inc. axes
  // TNtuple *ntuple = new TNtuple("ntuple","data from ascii file",				"x:y");

  // Loop to read the file, and print out the first 5 values to check if it's the right file.
  // while (1) {
  // in >> x >> y;
  // if (!in.good()) break;
  // // if (nlines < 5) printf("x=%8f, y=%8f\n",x,y);
  // printf("x=%8f, y=%8f\n",x,y);
  // h2->Fill(x,y);
  // ntuple->Fill(x,y);
  // nlines++;
  // }
  // printf(" found %d points\n",nlines);

  // in.close();

  // make sure this happens after the file is closed!
  // TGraph *g2 = new TGraph("cut_data.dat",format="%lg %lg",option=":,");

  // Creates a Root function based on function fitf above
  // TF1 *func = new TF1("fitf",fitf,1E9,1E12,2);
  // TF1 *func2 = new TF1("fitf",fitf,4E12,5E14,2);
  // TF1 *lambertfunc = new TF1("fitLambertW",fitLambertW,5e12,5E15,3);
  // TF1 *lambertCERNfunc = new TF1("fitLambertW",fitLambertW,5e12,1E16,3);
  // TF1 *func2 = new TF1("fitLambertW",fitf,1E13,1.1E16,3);

  // Sets initial values (guesses)
  // func->SetParameters(0.5,0); 
  // func2->SetParameters(0.5,0);
  // lambertfunc->SetParameters(4.27e-11,0.83,4.9e-6); // Based on the other straight line
  // lambertfunc->SetParameters(1.9e-17,1.279,1.1e-5); // Based on initial fits
  // lambertCERNfunc->SetParameters(4.27e-18,1.289,4.9e-6); // Based on initial fits

  // Fit histogram in range defined by function

  // h2->Fit(func2,"r+");

  // lambertCERNfunc->SetLineColor(4);
  // lambertCERNfunc->SetLineWidth(2);
  // lambertCERNfunc->SetLineStyle(2);


  TCanvas *c1 = new TCanvas("c1","c1",1000,800);
  // TGaxis *axis1 = new TGaxis(1E10,0.5,1E17,2E2,0,0);

  // c1->cd(); // I think this command makes c1 the default canvas
 
  TH2F *hpx = new TH2F("hpx","On the Fly (old results in red)",10,1E10,6.4E16,100,0.2,210.0);
  // axis range
  hpx->SetStats(kFALSE);// no statistics
  hpx->Draw();
  TGraph *gr1 = new TGraph("cut_data.dat");
  TGraph *gr2 = new TGraph("on_the_fly_test.dat",format="%*lg %*lg %*lg %lg %lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg %*lg",option=":,");
  // gr1->SetTitle("Fluence vs. Forward Voltage");

  // TGraph *cernGraph = new TGraph("CERN_guessed_data.dat");

  // gr1->Fit(func,"r");
  // gr1->Fit(lambertfunc,"r+");
  // c1->Divide(1,2);
  // c1->cd(1);
  // h2->SetMarkerStyle(2);
  // h2->SetMarkerSize(0.6);
  // h2->Draw();

  // c1->cd(2);
  // cernGraph->Draw("*");
  // cernGraph->SetMarkerStyle(4);
  // cernGraph->GetXaxis()->SetRangeUser(5E10,6.4E20);// axis1->Draw("same");
  gr1->Draw("*");
  gr2->Draw("*");
  gr1->SetFillColor(1);
  gr1->SetMarkerStyle(4);
  gr1->SetMarkerColor(2);

  // gr1->GetXaxis()->SetRangeUser(5E10,6.4E20);// axis1->Draw("same");


  // lambertCERNfunc->Draw("same");
  // gr1->Draw();
  // c1->cd(2);
  // lambertfunc->Draw();

  c1->SetLogx(1);
  c1->SetLogy(1);
  c1->SetTicks(2,2);		// This is for the ticks on both sides
}
